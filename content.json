{"posts":[{"title":"算法导论第四&amp;&amp;五章","text":"第四章 分治策略 本章主要介绍求解递归式的方法 4.1 最大子数组问题 典型例子是股票买入卖出问题 暴力求解思路：$\\Theta(n^2)$ 简便算法：转换为差值数组A[l,r]，求最大差值之和将数组分为A1[l,mid]和A2[mid+1,r]最大子数组的位置可能有三种情况： 完全位于A1 完全位于A2 两端分别位于A1A2 即跨越中点mid，易在线性时间内找出最大差值数组 伪代码12345678910111213141516FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high) left-sum = -∞ sum = O for i = mid downto low sum = sum+A[i] if sum &gt; left-sum left-sum = sum max-left = i right-sum = -∞ sum = O for j = mid + 1 to high sum=sum + A[j] if sum &gt; right-sum right-sum = sum max-right = j return (max-left, max-right, left-sum + right-sum) 12345678910111213FIND-MAXIMUM-SUBARRAY(A, low, high) if high == low return (low, high, A[low]) else mid =(low+high)/2 (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid) (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid+l. high) (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high) if left-sum &gt;= right-sum and left-sum &gt;= cross-sum return (left-low, left-high, left-sum else if rightr-sum &gt;= left-sum and right-sum &gt;= cross-sum return (right-low, right-high, right-sum) else return (cross-low, cross-high, cross-sum) 3. 练习部分4.1-5 线性时间解决最大子数组问题 123456789MaxSubarray(A) boundary=maxArray=A[1] for i=2 to A.length if boundary &gt;= 0 boundary += A[i] else boundary = A[i] if maxArray &lt; boundary maxArray = boundary return maxArray 4.2 矩阵乘法的Strassen算法 自然算法：$\\Omega(n^3)$ Strassen算法：$\\Theta(n^{lg7})$在分治法的基础上，利用数学运算技巧计算矩阵(具体方法略) 普通分治算法：$\\Omega(n^3)$伪代码实现12345678910SQUARE-MATRIX-MULTIPLY-RECURSIVE(A, B) n = A.rows if n==l cn =an • bn else partition A, B, and C as in equations (4. 9) C11 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A11,B11) + SQUARE-MATRIX-MDLTIPLY-RECURSIVE(A12, B21) C12 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A11,B12) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A12, B22) C21 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A21,B11) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A22, B21) C22 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A21,B12) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A22, B22) return C 4.3 用代入法求解递归式 代入法求解递归式分为两步： 猜测解的形式 用数学归纳法求出解中的常数，并证明解是正确的 有时你可能正确猜出了递归式解的渐近界，但莫名其妙地在归纳证明时失败了。问题常常出在归纳假设不够强，无法证出准确的界。当遇到这种障碍时，如果修改猜测，将它减去一个低阶的项，数学证明常常能顺利进行。 4.4 用递归树方法求解递归式 递归树最适合用来生成好的猜测，然后即可用代入法来验证猜测是否正确 当使用递归树来生成好的猜测时，常常需要忍受一点儿”不精确“，因为稍后才会验证猜测是否正确。 4.5 用主方法求解递归式对于$T(n)=aT(n/b)+f(n)$，其中a&gt;=1,b&gt;1(T(n/b)为向上取整向下取整不影响)，可以使用主方法：$$T(n)=\\begin{cases}\\Theta(n^{log_ba}) &amp; f(n)=O(n^{log_b{a-\\epsilon}}),\\epsilon&gt;0 \\\\Theta(n^{log_ba}*lgn) &amp; f(n)=\\Theta(n^{log_ba}) \\\\Theta(f(n)) &amp; f(n)=O(n^{log_b{a+\\epsilon}}),\\epsilon&gt;0，且对于某个常数c&lt;1和所有足够大的n有af(n/b)&lt;=cf(n)\\end{cases}$$ 第五章 概率分析和随机算法 5.1 雇用问题 应聘者i比i-1更有资格的概率为1/i，即：$E[x_i]=\\frac1i$则有$E[x]=lnn+O(1)$ 如果一个算法的行为不仅由输入决定，而且也由随机数生成器 (random-numbergenerator) 产生的数值决定，则称这个算法是随机的 (randomized) 在实践中，大多数编程环境会提供一个伪随机数生成器，它是一个确定性算法，返回值在统计上看起来是随机的 5.2 指示器随机变量 事件A对应的指示器随机变量 I{A}定义为：$$I(A)=\\begin{cases}1 &amp; 如果A发生\\0 &amp; 如果A不发生\\end{cases}$$ 5.3 随机算法以下是随机排列数组的两种方法： 朴素算法：一个通常的方法是为数组的每个元素 A[i]赋一个随机的优先级 P[i]，然后依据优先级对数组A中的元素进行排序。（时间复杂度为归并排序时间复杂度） 原址排列给定数组1234RANDOMIZE-IN-PLACE(A) n = A. length for i=l to n Swap(A[i],A[RANDOM(i, n)]) 时间复杂度为O(n) 练习部分5.3-3 假设我们不是将元素 A[i] 与子数组 A[i.. n] 中的一个随机元素交换，而是将它与数组任何位置上的随机元素交换：swap A[i] with A[RANDOM(1, n)]，那么他不是一个均匀随机算法。 5.4节为选看部分 5.4 概率分析和指示器随机变量的进一步使用","link":"/2024/11/23/post2-2/"},{"title":"算法导论-第一&amp;&amp;二三章笔记","text":"第一章 算法在计算中的作用 1.1 算法 非形式地说，算法 (algorithm) 就是任何良定义的计算过程 .数据结构是一种存储和组织数据的方式，旨在便于访问和修改。 这样的输入序列称为一个实例 (instance) 。一般来说，问题实例由计算该问题解所必需的（满足问题陈述中强加的各种约束的）输入组成。 P类问题：所有可以在多项式时间内求解的判定问题构成P类问题。 NP类问题：所有的非确定性多项式时间可解的判定问题构成NP类问题。 旅行商问题：等价于求图的最短哈密尔顿回路问题，是NP问题的一种。 凸壳：给定平面上的n个点，凸壳就是包含这些点的最小的凸多边形。 1.2 作为一种技术的算法 第二章 算法基础 2.1 插入排序1. 伪代码实现12345678INSERTION-SORT(A) for j = 2 to A. length key= A[j] i=j-1 while i &gt; 0 and A[i] &gt; key A[H 1] = A[i] i=i-1 A[i + 1] = key 2. 循环不变式循环不变式主要用来帮助我们理解算法的正确性。关千循环不变式，我们必须证明三条性质： 初始化：循环的第一次迭代之前，它为真。 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。 3. 练习部分2.1-4考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数A和B中。这两个整数的和应按二进制形式存储在一个 (n+1)元数组C中。请给出该问题的形式化描述，并写出伪代码。 12345678AddingBinary(A,B) carry = 0 //保存进位，最关键的一点 for i = n to 1 C[i+1]=(A[i]+B[i]+carry)(mod 2) if A[i]+B[i]+carry &gt;= 2 carry = 1 else carry = 0 c[1]=carry 2.2 分析算法1. RAM模型 对本书的大多数章节，我们假定一种通用的单处理器计算模型随机访问(random-access machine, RAM) 来作为我们的实现技术，算法可以用计算机程序来实现。在RAM模型中，指令一条接一条地执行，没有并发操作。 RAM 模型包含真实计算机中常见的指令：算术指令（如加法、减法、乘法、除法、取余、向下取整、向上取整）、数据移动指令（装入、存储、复制）和控制指令（条件与无条件转移、子程序调用与返回）。每条这样的指令所需时间都为常量。 我们还对每个数据字的规模假定一个范围。例如，当处理规模为n的输入时，我们一般假定对某个大于等于n的常量 c, 整数由clgn位来表示。我们要求c大于等于 1, 这样每个字都可以保存n的值，从而使我们能索引单个输入元素。我们限制常量，这样字长就不会任意增长。（如果字长可以任意增长，我们就能在一个字中存储巨量的数据，并且其上的操作都在常量时间内进行，这种情况显然不现实。) 真实的计算机包含一些上面未列出的指令，这些指令代表了 RAM 模型中的一个灰色区域。例如，指数运算是一条常量时间的指令吗？一般情况下不是；当 都是实数时，计算立需要若干条指令。然而，在受限情况下，指数运算又是一个常量时间的操作。许多计算机都有“左移”指令，它在常量时间内将一个整数的各位向左移k位。在大多数计算机中，将一个整数的各位向左移一位等价千将该整数乘以 2, 结果将一个整数的各位向左移 位等价千将该整数乘以2^k 。所以，只要 不大千一个计算机字中的位数，这样的计算机就可以由一条常量时间的指令来计算 2^k,即将整数1向左移k位。我们尽量避免 RAM 模型中这样的灰色区域，但是，当 是一个足够小的正整数时，我们将把护的计算看成一个常量时间的操作。 2. 插入排序算法的分析3. 练习部分2.2-2 选择排序算法 1234567SelectionSort(A) for i =1 to n-1 min = i for j = i+1 to n if A[j] &lt; A[min] min = j Swap(A[min],A[i]) 2.3 设计算法1. 分治法 分治模式在每层递归时都有三个步骤： 分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。 解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。 合并这些子问题的解成原问题的解。 分治排序伪代码实现1234567891011121314151617181920212223MERGE(A, p, q, r) n1 = q - P + 1 n2 = r - q for i = 1 to n1 L[i] = A[p + i - l] for j = l to n2 R[j] = A[q + j] L[n1+ l] = ∞ ，R[n,+ l] = ∞ //设置哨兵节点，简化步骤 i = 1 ，j = 1 for k = p to r if L[i] &lt;= R[j] A[k] = L[i] i = i+1 else A[k] = R[j] j = j+1 MERGE-SORT(A, p, r) if p &lt; r q = L(p+r)/2 MERGE-SORT(A, p, q) MERGE-SORT(A, q+l, r) MERGE(A, p, q, r) 2. 分析分治算法 分析分治算法 T(n) 是规模为n的一个问题的运行时间 若问题规模足够小，如对某个常量 c, n&lt;=c, 则直接求解需要常量时间 假设把原问题分解成a个子问题，每个子问题的规模是原问题的1/b 如果分解问题成子问题需要时间 D(n), 合并子问题的解成原问题的解需要时间 C(n),$$T(n)=\\begin{cases}\\Theta(1) &amp; n&lt;=c \\aT(n/b)+D(n)+C(n) &amp; else\\end{cases}$$ 针对归并排序$$T(n)=\\begin{cases} \\Theta(1) &amp; n=1 \\ 2T(n/2)+\\Theta(n) &amp; n&gt;1 \\end{cases}$$ 可解得$T(n)=\\Theta(nlgn)$ 3. 练习部分2.3-5 二分查找算法 12345678910BinSearch(a,b,v) if a &gt; b return NIL m = (a+b)/2 if m = v return m else if m &lt; v return BinSearch(a,m,v) else return BinSearch(m+1,b,v) 思考题2-1 在归并排序中对小数组采用插入排序2-2 冒泡排序 12345BubbleSort(A) for i = 1 to A.length-1 for j = A.length downto i+1 if A[j] &lt; A[j-1] Swap(A[j],A[j-1]) 2-3 霍纳规则计算多项式 123y=0for i = n downto 0 y=ai+x*y 2-4 (逆序对） 假设 A[1.. n] 是一个有n个不同数的数组。若i&lt;j且A[i]&gt;A[j]，则对偶(i, j) 称为A的一个逆序对 (inversion).给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况需要$\\Theta$(nlgn) 时间。（提示：修改归并排序。） 12345678M.MERGE-SORT(A, p, r) if p &lt; r q = L(P+r)/2 left = M.MERGE-SORT(A, p, q) right = M.MERGE-SORT(A, q+l, r) inv = M.MERGE(A, p, q, r) return inv return 0 记录归并排序中数字反转的次数，得到的最终结果即是逆序对的数量 第三章 函数的增长 3.1 渐近记号 O(n)：只存在渐近上界与o(n)的关系：相当于&lt;=和&lt;的关系 $\\Omega(n)$：只存在渐近下界与$\\omega(n)$的关系：相当于&gt;=和&gt;的关系 $\\Theta(n)$：存在渐近上界与下界 3.2 标准记号与常用函数 多重对数函数我们使用记号lg来表示多重对数，其中：$$ lg2 = 1 \\ lg4 = 2 \\ lg16 = 3 \\ lg*2^{16}=4 \\ …$$ 思考题","link":"/2024/11/23/post2-1/"},{"title":"算法导论第六章","text":"如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是原址的 (in place) 主要排序算法的时间复杂度 第六章 堆排序 6.1 堆 （二叉）堆是一个数组，它可以被看成一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。 表示堆的数组 包括两个属性： A. length给出数组元素的个数， A. heap-size 表示有多少个堆元素存储在该数组中。。也就是说，虽然 A[1.. A. length] 可能都存有数据，但只有A[1. . A. heap-size] 中存放的是堆的有效元素。 树的根结点是A[1], 这样给定一个结点的下标 i, 我们很容易计算得到它的父结点、左孩子和右孩子的下标：123parent(i) return i/2left(i) return 2iright(i) return 2i+1 可用左移，右移操作实现 最大堆：$A[parent(i)]&gt;=A[i]$最小堆：$A[parent(i)]&lt;=A[i]在堆排序算法中，我们使用的是最大堆。最小堆通常用千构造优先队列 6.2 维护堆的性质 伪代码实现1234567891011MAX-HEAPIFY (A, i) l= LEFT (i) r= RIGHT (i) if l &lt;= A.heap-size and A[l] &gt; A[i] largest = l else largest = i if r &lt;= A.heap-size and A[r] &gt; A[largest] largest = r if larget != i exchange A[i] with A[largest] MAX-HEAPIFY (A, largest) 迭代式：$T(n) \\geq T(2/3n)+\\Theta(1)$迭代式的解为:$O(lgn)$ 练习部分6.2-5 用循环控制结构取代递归 1234567891011while i &lt; A.heap-size//以下都一样 l= LEFT (i) r= RIGHT (i) if l &lt;= A.heap-size and A[l] &gt; A[i] largest = l else largest = i if r &lt;= A.heap-size and A[r] &gt; A[largest] largest = r if larget != i exchange A[i] with A[largest] else return A//不同点 6.3 建堆 伪代码实现1234BUILD-MAX-HEAP(A) A. heap-size = A. length//初始化堆大小 for i = ⌊A. length/2⌋ downto 1 MAX-HEAPIFY(A, i) 时间复杂度：$O(n)$ 大部分i都是属于堆的底部，所以表面上每个MAX-HEAPIFY是用O(lgn)时间，但其实是用常数时间（具体证明略） 6.4 堆排序算法 伪代码实现123456HEAPSORT(A) BUILD-MAX-HEAP(A) for i = A. length downto 2 exchange A[1] with A[i] //将最大元素移动到数组末尾 A. heap-size = A. heap-size —1 //弹出最大元素 MAX-HEAPIFY(A, 1) 时间复杂度：$O(nlgn)$ 与上一个不同，这里，大部分ii是位于堆的顶部，用O(lgn)时间 6.5 优先队列 优先队列 (priority queue) 是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字 (key) 。 一个最大优先队列支待以下操作：INSERT(S, x): 把元素x插入集合S中。这一操作等价于 S=S$\\cup${x}MAXIMUM(S): 返回S中具有最大键字的元素。return A[1]EXTRACT-MAX（S): 去掉并返回S中的具有最大键字的元素。INCREASE-KEY(S, x, k): 在键值k处添加一个键值x，如果其小于k则无反应，大于k则替换并且优化到最大堆 过程HEAP-EXTRACT-MAX伪代码12345678HEAP-EXTRACT-MAX(A) if A. heap-size &lt; l error &quot;heap underflow&quot; max= A[l] A[l] = A[A. heap-size] //最后一个元素可能会破坏最大堆的性质，所以要调整 A. heap-size = A. heap-size —l MAX-HEAPIFY(A, 1) return max 时间复杂度：$O(lgn)$ 过程HEAP-INCREASE-KEY伪代码1234567HEAP-INCREASE-KEY(A, i, key) if key &lt; A[i] error &quot;new key is smaller than current key&quot; A[i] = key while i &gt; 1 and A[PARENT(i)] &lt; A[i] exchange A[i] with A[PARENT(i)] i = PARENT(i) 时间复杂度：$O(lgn)$ 过程MAX-HEAP-INSERT伪代码1234MAX-HEAP-INSERT(A, key) A. heap-size = A. heap-size + 1 A[A. heap-size] = -∞ HEAP-INCREASE-KEY(A, A. heap-size, key) 时间复杂度：$O(lgn)$ 练习部分","link":"/2024/11/23/post2-3/"},{"title":"","text":"第一章 计算机系统漫游 计算机系统是由硬件和系统软件组成的 1.1 信息就是位+上下文 字节：8个位 只由像ASCII码一样的标准字符构成的文件称为文本文件，其他文件称为二进制文件 系统中所有的信息都是由一串比特（即位）表示的，区分它们的是这些信息的上下文。 1.2 程序被其他程序翻译成不同的格式 一个.c程序被转化为可执行目标文件（.exe）需要经历四个阶段（预处理器、编译器、汇编器、链接器），这四个一起构成了编译系统 预处理器：根据以字符‘#’开头的命令，修改原始的c程序，生成另一个c程序，后缀名为.i 编译器：将.i文件翻译成.s文件，.s文件是汇编语言程序 汇编器：将汇编语言程序翻译成机器语言指令，生成.o文件，该文件是一个二进制文件 链接器：以“printf”函数为例子，该函数是标准C库中的函数，其存在于另一个.o文件中，链接器将其合并，得到可执行文件 1.3 了解编译系统如何工作是大有益处的 优化程序性能：通过了解机器语言指令，对程序优化。如：switch和if-else语句哪个更高效 | 函数调用的开销 | while循环和for循环哪个更有效等 理解链接时出现的错误：如“无法解析的引用” | 静态变量和全局变量的区别等 避免安全漏洞：堆栈原理即缓冲区溢出错误等 1.4 处理器读并解释储存在内存中的指令 shell是一个命令行解释器 如果命令行的第一个单词不是内置的shell命令，那么就会默认是某个可执行文件的名字，将其打开 1.4.1 系统的硬件组成 总线 总线是贯穿系统的一组电子管道 其传送定长的字节块（即字），字中的字节数是系统的重要参数，一般是8个字节（即64位系统） I/O设备 简单的说，包括鼠标键盘、显示器、长期存储数据的磁盘等 每个I/O设备通过一个控制器或者适配器与总线相连 主存（RAM） 主存是一个临时存储设备 在处理器执行程序的时候，主存存放程序和程序处理的数据 主存由一组动态随机存取存储器（DRAM）构成 从逻辑上说，存储器就是一个线性数组 处理器（CPU） CPU是解释（执行）存储在主存中指令的引擎 处理器的核心是程序计数器（PC），它是一个寄存器，寄存器是一个大小为一个字的存储设备 处理器有着相应的指令集架构 处理器从程序计数器指向的内存（即主存）处读取指令，然后执行指令对应的简单操作，再更新PC，使其指向下一条指令 （这条指令不一定与上一条指令物理相邻） 简单操作： 围绕主存、寄存器文件、算数逻辑单元（ALU）进行。 （寄存器文件：由一些(部分)寄存器组成，是一个小的存储设备，每个寄存器都有唯一的名字） 以下是一些简单操作的例子： 加载：从主存加载一个字节或字到寄存器 存储：从寄存器复制一个字节或字到主存上的某个位置 操作：从两个寄存器中提取两个字到ALU，进行运算 跳转：指令本身中抽取一个字复制到PC中 指令集架构：每条机器代码指令的效果 微体系架构：处理器本身是如何实现的 1.4.2 运行hello程序 直接存储器存取技术：数据直接从磁盘加载到主存中，不需要经过处理器。 1.5 高速缓存至关重要 加快处理器的运行速度比加快主存的运行速度容易得多 故，设计了高速缓存存储器（cache），一般有L1,L2,L3三级，其中L1最快（最接近寄存器），这是用静态随机访问存储器（SRAM）实现的。 1.6 存储设备形成层次结构 1.7 操作系统管理硬件 可以把操作系统视作应用程序和硬件之间的一层软件，所有应用程序都要通过操作系统来访问硬件 操作系统的基本功能： 防止硬件被失控的应用程序滥用 向应用程序提供一个一致的机制 操作系统是由三个抽象概念（进程，虚拟内存和文件）实现的 进程：对处理器，主存，IO设备的抽象表示 虚拟内存：对主存，磁盘的抽象表示 文件：对IO设备的抽象表示 1.7.1 进程 并发运行：一个进程的指令和另一个进程的指令是交错执行的，这种机制叫做上下文切换，这使得运行的进程数可以多于CPU个数 多核CPU在一个时刻可以运行多个程序 注意：CPU个数和CPU核数是两个概念 CPU个数（也叫物理CPU数量）：指的是计算机中实际存在的处理器的数量 CPU核数（也叫核心数）：指的是每个物理CPU中的处理核心的数量 上下文切换是通过操作系统内核（kernel）管理的 操作系统内核不是进程，而是管理所有进程的代码集合，它一直在主存中运行 1.7.2 线程 一个进程中有多个线程组成 线程之间共用数据内存和代码等 线程比进程更高效（调度消耗少） 多线程可以很好的是程序运行的更快 1.7.3 虚拟内存 虚拟内存为每个进程提供了一种假象：每个进程都在独立占用主存。 堆：可以在运行时动态扩展收缩（malloc / free） 共享库：即dll文件 栈：编译器用来实现函数调用，每调用一个函数，栈就会增长，返回就会收缩 1.7.4 文件 文件就是字节序列 每个IO设备都可以看做是一个文件 1.8 系统之间利用网络通信 利用网络复制信息 1.9 重要主题1.9.1 Amdahi定律 想要显著加速整个系统，必须提升大部分部件的速度 1.9.2 并发和并行 线程级并发 指令级并行：单个时钟周期可以运行多条机器指令 单指令多数据并行：和底层硬件相关 1.9.3 计算机系统中抽象的重要性 1.10 小结","link":"/2024/11/23/post1_1/"}],"tags":[{"name":"算法导论","slug":"算法导论","link":"/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}],"categories":[],"pages":[]}